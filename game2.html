<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Henrik World | Chess AI (Fixed)</title>
<link rel="icon" href="images/favicon.png" type="image/png">
<style>
  body { margin:0; font-family:Arial,sans-serif; background:#f0f0f0; display:flex; flex-direction:column; min-height:100vh;}
  header {background:#fff; padding:1rem 2rem; position:sticky; top:0; display:flex; justify-content:space-between; align-items:center; box-shadow:0 4px 8px rgba(0,0,0,.1);}
  header h1{margin:0; font-size:1.5rem;}
  header .header-right{display:flex; align-items:center; gap:1rem;}
  header span.home-emoji{cursor:pointer; font-size:1.5rem;}
  #gameTimer {background:#fff; padding:1rem 2rem; border-radius:12px; margin:1rem auto; max-width:600px; text-align:center; box-shadow:0 4px 8px rgba(0,0,0,.1); font-weight:bold;}
  main{flex:1; display:flex; justify-content:center; align-items:flex-start; padding:2rem 1rem;}
  .board-wrap{display:grid; grid-template-columns:2fr 1fr; gap:1.2rem; max-width:900px; width:100%;}
  @media(max-width:700px){.board-wrap{grid-template-columns:1fr;}}
  .card{background:#fff; border-radius:12px; padding:1rem; box-shadow:0 4px 8px rgba(0,0,0,.1);}
  #chessboard{display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr); gap:2px; max-width:600px; width:100%; margin:0 auto;}
  .cell{aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none;}
  .cell img{width:95%; height:95%;}
  .white{background:#f0d9b5;}   /* light brown */
  .black{background:#b58863;}   /* dark brown */
  .selected{outline:3px solid #1e90ff;}
  .sidebar .card{margin-bottom:1rem;}
  .settings label{display:block; margin-top:0.6rem; font-weight:bold;}
  .settings select{width:100%; padding:0.4rem; border-radius:6px; margin-top:0.2rem;}
  .btn {
    background-color: #fff;
    color: #1e90ff;
    border: 3px solid #1e90ff;
    border-radius: 8px;
    padding: 0.8rem 1.5rem;
    font-size: 1.1rem;
    cursor: pointer;
    margin-top: 0.5rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
  }
  .btn:hover {
    background-color: #e6f0ff;
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  .btn:active {
    transform: scale(1.02);
    background-color: #cce0ff;
  }
  footer{text-align:center; color:#555; margin:2rem 1rem;}
  #gameOverlay {
    position: fixed; top:0; left:0;
    width:100%; height:100%;
    background: rgba(0,0,0,0.7);
    color:#fff; display:flex;
    justify-content:center; align-items:center;
    font-size:3rem; font-weight:bold;
    z-index:999; display:none; text-align:center;
  }
  .turn-card {
    background: #fff;
    border-radius: 12px;
    padding: 1rem;
    box-shadow: 0 4px 8px rgba(0,0,0,.1);
    text-align: center;
    margin-top: 1rem;
    font-size: 1.3rem;
    font-weight: bold;
  }
</style>
</head>
<body>
<header>
  <h1>üåç Henrik World</h1>
  <div class="header-right">
    <span class="home-emoji" onclick="location.href='index.html'">üè†</span>
  </div>
</header>

<div id="gameTimer">‚è± Time: 00:00</div>

<main>
  <div class="board-wrap">
    <div class="card">
      <div id="chessboard"></div>
    </div>
    <div class="sidebar">
      <div class="card settings">
        <h3>‚öôÔ∏è Settings</h3>
        <label for="difficulty">Difficulty</label>
        <select id="difficulty">
          <option value="easy" selected>Easy</option>
          <option value="medium">Medium</option>
          <option value="hard">Hard</option>
        </select>
        <label for="first">Who goes first?</label>
        <select id="first">
          <option value="player" selected>Player</option>
          <option value="ai">AI</option>
        </select>
        <button id="btnStart" class="btn">‚ñ∂Ô∏è Start Game</button>
        <button id="btnReset" class="btn">üîÑ Reset Board</button>
      </div>

      <div class="card turn-card">
        Next Turn: <span id="turnIndicatorCard">üßë Player</span>
      </div>
    </div>
  </div>
</main>

<footer>&copy; 2025 henrikworld.com. All rights reserved;</footer>

<div id="gameOverlay">GAME OVER</div>

<script>
/* ---------- DOM nodes ---------- */
const chessboard = document.getElementById('chessboard');
const diffSelect = document.getElementById('difficulty');
const firstSelect = document.getElementById('first');
const gameTimer = document.getElementById('gameTimer');
const gameOverlay = document.getElementById('gameOverlay');
const turnIndicatorCard = document.getElementById('turnIndicatorCard');
const btnStart = document.getElementById('btnStart');
const btnReset = document.getElementById('btnReset');

/* ---------- Game state ---------- */
let board = new Array(64).fill(0);
let turn = 'player';
let selected = null;
let difficulty = 'easy';
let secondsElapsed = 0;
let timerInterval = null;

/* piece -> filename mapping */
const pieceMap = {
  "1": "white-pawn.png","2": "white-rook.png","3": "white-knight.png",
  "4": "white-bishop.png","5": "white-queen.png","6": "white-king.png",
  "-1": "black-pawn.png","-2": "black-rook.png","-3": "black-knight.png",
  "-4": "black-bishop.png","-5": "black-queen.png","-6": "black-king.png"
};

/* starting board */
const startingBoard = [
  -2,-3,-4,-5,-6,-4,-3,-2,
  -1,-1,-1,-1,-1,-1,-1,-1,
   0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,
   1,1,1,1,1,1,1,1,
   2,3,4,5,6,4,3,2
];

/* ---------- UI / Timer ---------- */
function createBoard(){
  chessboard.innerHTML = '';
  for(let i=0;i<64;i++){
    const cell = document.createElement('div');
    const row = Math.floor(i/8);
    const col = i % 8;
    cell.classList.add(((row + col) % 2 === 0) ? 'white' : 'black', 'cell');
    cell.dataset.idx = i;
    cell.onclick = () => cellClick(i);
    chessboard.appendChild(cell);
  }
}

function renderBoard(){
  const cells = document.querySelectorAll('.cell');
  for(let i=0;i<64;i++){
    const piece = board[i];
    cells[i].innerHTML = piece === 0 ? '' : `<img src="images/game2/${pieceMap[piece.toString()]}" alt="">`;
    cells[i].classList.remove('selected');
    if(selected === i) cells[i].classList.add('selected');
  }
}

function showOverlay(message){
  gameOverlay.textContent = message;
  gameOverlay.style.display = 'flex';
}
function hideOverlay(){ gameOverlay.style.display = 'none'; }

function startTimer(){
  clearInterval(timerInterval);
  secondsElapsed = 0;
  updateTimer();
  timerInterval = setInterval(()=>{ secondsElapsed++; updateTimer(); }, 1000);
}
function stopTimer(){ clearInterval(timerInterval); }
function updateTimer(){
  const minutes = String(Math.floor(secondsElapsed/60)).padStart(2,'0');
  const seconds = String(secondsElapsed % 60).padStart(2,'0');
  gameTimer.textContent = `‚è± Time: ${minutes}:${seconds}`;
}
function updateTurnIndicator(){ turnIndicatorCard.textContent = (turn === 'player') ? 'üßë Player' : 'ü§ñ AI'; }

/* ---------- Chess logic ---------- */
function getRow(i){ return Math.floor(i/8); }
function getCol(i){ return i % 8; }
function isEmpty(i){ return board[i] === 0; }
function isOpponent(i, isWhite){ return board[i] !== 0 && Math.sign(board[i]) !== (isWhite ? 1 : -1); }

/* Moves generation (same as before) */
function getPawnMoves(idx, isWhite){
  const moves = [];
  const row = getRow(idx), col = getCol(idx);
  const dir = isWhite ? -1 : 1;
  const oneStep = idx + dir*8;
  if(oneStep>=0 && oneStep<64 && isEmpty(oneStep)) {
    moves.push(oneStep);
    const startRow = isWhite ? 6 : 1;
    const twoStep = idx + dir*16;
    if(row===startRow && isEmpty(twoStep)) moves.push(twoStep);
  }
  if(col>0 && oneStep-1>=0 && isOpponent(oneStep-1,isWhite)) moves.push(oneStep-1);
  if(col<7 && oneStep+1<64 && isOpponent(oneStep+1,isWhite)) moves.push(oneStep+1);
  return moves;
}
function getRookMoves(idx,isWhite){
  const moves=[]; const row=getRow(idx), col=getCol(idx);
  const dirs=[[-1,0],[1,0],[0,-1],[0,1]];
  dirs.forEach(([dr,dc])=>{
    let r=row+dr,c=col+dc;
    while(r>=0 && r<8 && c>=0 && c<8){
      const newIdx=r*8+c;
      if(isEmpty(newIdx)) moves.push(newIdx);
      else { if(isOpponent(newIdx,isWhite)) moves.push(newIdx); break; }
      r+=dr; c+=dc;
    }
  });
  return moves;
}
function getKnightMoves(idx,isWhite){
  const moves=[]; const row=getRow(idx), col=getCol(idx);
  const offsets=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
  offsets.forEach(([dr,dc])=>{
    const r=row+dr,c=col+dc;
    if(r>=0 && r<8 && c>=0 && c<8){
      const newIdx=r*8+c;
      if(isEmpty(newIdx)||isOpponent(newIdx,isWhite)) moves.push(newIdx);
    }
  });
  return moves;
}
function getBishopMoves(idx,isWhite){
  const moves=[]; const row=getRow(idx), col=getCol(idx);
  const dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];
  dirs.forEach(([dr,dc])=>{
    let r=row+dr, c=col+dc;
    while(r>=0 && r<8 && c>=0 && c<8){
      const newIdx=r*8+c;
      if(isEmpty(newIdx)) moves.push(newIdx);
      else { if(isOpponent(newIdx,isWhite)) moves.push(newIdx); break; }
      r+=dr; c+=dc;
    }
  });
  return moves;
}
function getQueenMoves(idx,isWhite){ return getRookMoves(idx,isWhite).concat(getBishopMoves(idx,isWhite)); }
function getKingMoves(idx,isWhite){
  const moves=[]; const row=getRow(idx), col=getCol(idx);
  const offsets=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  offsets.forEach(([dr,dc])=>{
    const r=row+dr,c=col+dc;
    if(r>=0 && r<8 && c>=0 && c<8){
      const newIdx=r*8+c;
      if(isEmpty(newIdx)||isOpponent(newIdx,isWhite)) moves.push(newIdx);
    }
  });
  return moves;
}

function rawValidMoves(idx){
  const piece=board[idx];
  if(piece===1) return getPawnMoves(idx,true);
  if(piece===-1) return getPawnMoves(idx,false);
  if(piece===2) return getRookMoves(idx,true);
  if(piece===-2) return getRookMoves(idx,false);
  if(piece===3) return getKnightMoves(idx,true);
  if(piece===-3) return getKnightMoves(idx,false);
  if(piece===4) return getBishopMoves(idx,true);
  if(piece===-4) return getBishopMoves(idx,false);
  if(piece===5) return getQueenMoves(idx,true);
  if(piece===-5) return getQueenMoves(idx,false);
  if(piece===6) return getKingMoves(idx,true);
  if(piece===-6) return getKingMoves(idx,false);
  return [];
}

/* ---------- FIXED isKingInCheck ---------- */
function isKingInCheck(isWhite){
  const king = board.findIndex(p => p === (isWhite ? 6 : -6));
  if(king===-1) return true;
  for(let i=0;i<64;i++){
    const piece=board[i];
    if(piece===0) continue;
    if(Math.sign(piece)!==(isWhite?1:-1)){
      let moves=[];
      const absPiece=Math.abs(piece);
      if(absPiece===1) moves=getPawnMoves(i,piece>0);
      else if(absPiece===2) moves=getRookMoves(i,piece>0);
      else if(absPiece===3) moves=getKnightMoves(i,piece>0);
      else if(absPiece===4) moves=getBishopMoves(i,piece>0);
      else if(absPiece===5) moves=getQueenMoves(i,piece>0);
      else if(absPiece===6) moves=getKingMoves(i,piece>0);

      if(absPiece===2||absPiece===4||absPiece===5){
        moves=moves.filter(dest=>isPathClear(i,dest));
      }

      if(moves.includes(king)) return true;
    }
  }
  return false;
}

function isPathClear(from,to){
  const fromRow=Math.floor(from/8), fromCol=from%8;
  const toRow=Math.floor(to/8), toCol=to%8;
  const dRow=Math.sign(toRow-fromRow);
  const dCol=Math.sign(toCol-fromCol);
  let r=fromRow+dRow, c=fromCol+dCol;
  while(r!==toRow||c!==toCol){
    if(board[r*8+c]!==0) return false;
    r+=dRow; c+=dCol;
  }
  return true;
}

/* ---------- Other logic (moves, AI, timer, buttons) ---------- */
/* keep the same logic as in your original code for move validation, AI, and buttons */
function filterLegalMoves(idx, moves){
  const piece = board[idx];
  const isWhite = piece > 0;
  return moves.filter(dest => {
    const backup = board.slice();
    board[dest]=board[idx]; board[idx]=0;
    const inCheck=isKingInCheck(isWhite);
    board=backup;
    return !inCheck;
  });
}
function getValidMoves(idx){ return filterLegalMoves(idx, rawValidMoves(idx)); }

function isCheckmate(isWhite){
  for(let i=0;i<64;i++){
    if(Math.sign(board[i])===(isWhite?1:-1)&&getValidMoves(i).length>0) return false;
  }
  return isKingInCheck(isWhite);
}

function isStalemate(isWhite){
  for(let i=0;i<64;i++){
    if(Math.sign(board[i])===(isWhite?1:-1)&&getValidMoves(i).length>0) return false;
  }
  return !isKingInCheck(isWhite);
}

/* ---------- Player interaction ---------- */
function cellClick(i){
  if(turn==='ai'||gameOverlay.style.display==='flex') return;
  const piece=board[i];
  if(selected===null){
    if(piece>0){ selected=i; renderBoard(); }
    return;
  }
  const valid=getValidMoves(selected);
  if(valid.includes(i)){
    board[i]=board[selected]; board[selected]=0; selected=null; renderBoard();
    for(let k=0;k<64;k++){
      if(board[k]===1&&getRow(k)===0) board[k]=5;
      if(board[k]===-1&&getRow(k)===7) board[k]=-5;
    }
    if(isCheckmate(false)){ showOverlay("You Won!"); stopTimer(); return; }
    else if(isStalemate(false)){ showOverlay("Stalemate!"); stopTimer(); return; }
    turn='ai'; updateTurnIndicator(); setTimeout(aiMove,200);
  } else { selected=null; renderBoard(); }
}

/* ---------- AI logic, minimax & execution ---------- */
/* same as original code, no changes needed for AI */
const pieceValue = {
  1:100,2:500,3:320,4:330,5:900,6:20000,
  "-1":-100,"-2":-500,"-3":-320,"-4":-330,"-5":-900,"-6":-20000
};

function evaluateBoard(boardState){
  return boardState.reduce((s,piece)=>s+(pieceValue[piece]||0),0);
}
function generateMoves(isWhite){
  const moves=[];
  for(let i=0;i<64;i++){
    if(board[i]===0) continue;
    if((isWhite&&board[i]>0)||(!isWhite&&board[i]<0)){
      const valids=getValidMoves(i);
      valids.forEach(dest=>moves.push({from:i,to:dest}));
    }
  }
  return moves;
}

function minimax(depth,alpha,beta,isMaximizing){
  if(depth===0) return evaluateBoard(board);
  const moves=generateMoves(isMaximizing);
  if(moves.length===0) return evaluateBoard(board);
  if(isMaximizing){
    let maxEval=-Infinity;
    for(const move of moves){
      const backup=board.slice();
      board[move.to]=board[move.from]; board[move.from]=0;
      if(board[move.to]===1&&getRow(move.to)===0) board[move.to]=5;
      if(board[move.to]===-1&&getRow(move.to)===7) board[move.to]=-5;
      const evalScore=minimax(depth-1,alpha,beta,false);
      board=backup;
      if(evalScore>maxEval) maxEval=evalScore;
      if(evalScore>alpha) alpha=evalScore;
      if(beta<=alpha) break;
    }
    return maxEval;
  } else {
    let minEval=Infinity;
    for(const move of moves){
      const backup=board.slice();
      board[move.to]=board[move.from]; board[move.from]=0;
      if(board[move.to]===1&&getRow(move.to)===0) board[move.to]=5;
      if(board[move.to]===-1&&getRow(move.to)===7) board[move.to]=-5;
      const evalScore=minimax(depth-1,alpha,beta,true);
      board=backup;
      if(evalScore<minEval) minEval=evalScore;
      if(evalScore<beta) beta=evalScore;
      if(beta<=alpha) break;
    }
    return minEval;
  }
}

function aiMove(){
  const allMoves=generateMoves(false);
  if(allMoves.length===0){ turn='player'; updateTurnIndicator(); return; }
  let chosenMove=null;
  if(difficulty==='easy') chosenMove=allMoves[Math.floor(Math.random()*allMoves.length)];
  else{
    const depth=(difficulty==='medium')?2:3;
    let bestScore=Infinity;
    allMoves.sort((a,b)=>{const aTarget=board[a.to],bTarget=board[b.to]; return ((bTarget?Math.abs(bTarget):0)-(aTarget?Math.abs(aTarget):0));});
    for(const move of allMoves){
      const backup=board.slice();
      board[move.to]=board[move.from]; board[move.from]=0;
      if(board[move.to]===1&&getRow(move.to)===0) board[move.to]=5;
      if(board[move.to]===-1&&getRow(move.to)===7) board[move.to]=-5;
      const score=minimax(depth-1,-Infinity,Infinity,true);
      board=backup;
      if(score<bestScore){ bestScore=score; chosenMove=move; }
    }
    if(!chosenMove) chosenMove=allMoves[Math.floor(Math.random()*allMoves.length)];
  }
  board[chosenMove.to]=board[chosenMove.from]; board[chosenMove.from]=0;
  if(board[chosenMove.to]===1&&getRow(chosenMove.to)===0) board[chosenMove.to]=5;
  if(board[chosenMove.to]===-1&&getRow(chosenMove.to)===7) board[chosenMove.to]=-5;
  renderBoard();
  if(isCheckmate(true)){ showOverlay("You Lost!"); stopTimer(); return; }
  else if(isStalemate(true)){ showOverlay("Stalemate!"); stopTimer(); return; }
  turn='player'; updateTurnIndicator();
}

/* ---------- Buttons ---------- */
btnStart.onclick=()=>{
  hideOverlay();
  board=startingBoard.slice();
  difficulty=diffSelect.value;
  turn=(firstSelect.value==='player')?'player':'ai';
  selected=null; updateTurnIndicator(); renderBoard(); startTimer();
  if(turn==='ai') setTimeout(aiMove,300);
};
btnReset.onclick=()=>{
  hideOverlay();
  board=new Array(64).fill(0);
  selected=null; turn='player'; updateTurnIndicator(); renderBoard(); stopTimer();
};

/* initial setup */
createBoard(); board=startingBoard.slice(); renderBoard(); updateTurnIndicator();
</script>
</body>
</html>
